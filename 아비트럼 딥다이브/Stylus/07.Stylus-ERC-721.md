# ìŠ¤íƒ€ì¼ëŸ¬ìŠ¤ë¥¼ ì´ìš©í•œ NFT ë§Œë“¤ê¸°

## 1. ì‹œì‘í•˜ê¸°

NFTë¥¼ êµ¬ì¶•í•˜ê³  ë°°í¬í•˜ë ¤ë©´ ëª‡ê°€ì§€ í•„ìš”í•˜ë‹¤.

ê¸°ë³¸ì ì¸ í™˜ê²½ì„¤ì •ì´ ë˜ì–´ ìˆë‹¤ëŠ” ê°€ì •í•˜ì— ì§„í–‰í•œë‹¤.

## 2. NFT ë§Œë“¤ê¸°

```rust
git clone https://github.com/OffchainLabs/stylus-workshop-nft.git

cd stylus-workshop-nft
```

ìœ„ íŒŒì¼ì€ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì„±ìœ¼ë¡œ ë˜ì–´ìˆë‹¤.

`src/` ë””ë ‰í† ë¦¬ì—ì„œ ë‹¤ìŒ ì†ŒìŠ¤ íŒŒì¼ì„ ë³¼ ìˆ˜ ìˆë‹¤. ê°ê° ëª©ì ì´ ìˆìœ¼ë©°, ê° íŒŒì¼ ë‚´ì— ê´€ë ¨ ë¬¸ì„œê°€ ìˆë‹¤.

| íŒŒì¼                               | ì •ë³´                             |
| :--------------------------------- | :------------------------------- |
| [`erc721.rs`](erc721.rs)           | [ERC-721 í‘œì¤€][erc721]ì„ êµ¬í˜„.   |
| [`main.rs`](src/main.rs)           | ì§„ì…ì ì„ ì •ì˜.                   |
| [`utils.rs`](src/utils.rs)         | ì˜¨ì²´ì¸ png ìƒì„±ì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹°. |
| [`print_art.rs`](src/print_art.rs) | ì½˜ì†”ì— NFTë¥¼ ì¸ì‡„ ğŸ‘€             |
| [`art.rs`](art.rs)                 | **NFTë¥¼ ê·¸ë¦´ ìˆ˜ ìˆëŠ” ê³³ ğŸ˜„**     |

### art.rs ì¤‘ìš” ì½”ë“œ

generate_nft fn ì„ í†µí•´ì„œ ì•„ë˜ì™€ ê°™ì€ ì´ë¯¸ì§€ê°€ ê·¸ë ¤ì§„ë‹¤.

```rust
pub fn generate_nft(address: Address, token_id: U256) -> Image<32, 32> {
    let mut hasher = FnvHasher::new();
    hasher.update(token_id.as_le_slice());
    hasher.update(address.as_slice());
    let mut rng = Rng::with_seed(hasher.output());

    let bg_color = Color::from_hex(0xe3066e);
    let fg_color = Color {
        red: rng.u8(..),
        green: rng.u8(..),
        blue: rng.u8(..),
    };

    let mut image = Image::new(bg_color);

    image.draw_gradient(Color::from_hex(0xff0000), Color::from_hex(0x0000ff));
    image.draw_line(Cell::new(4, 4), Cell::new(4, 6), fg_color);
    image.draw_line(Cell::new(10, 4), Cell::new(10, 6), fg_color);
    image.draw_ellipse(Cell::new(7, 9), 3, 3, [false, false, true, true], fg_color);
    image
}
```

### ì´ë¯¸ì§€ print

```rust
cargo test print_art -- --nocapture
```

ìœ„ ëª…ë ¹ì–´ë¥¼ ì¹˜ë©´ ì•„ë˜ì™€ ê°™ì´ png íŒŒì¼ì´ draw ëœë‹¤.
![alt text](image.png)

### ë°°í¬

ì•„ë˜ ëª…ë ¹ì–´ë¥¼ í†µí•´ ë°°í¬ë¥¼ í™•ì¸í•œë‹¤.

```rust
cargo stylus check

cargo stylus check --private-key <í”„ë¼ì´ë¹— í‚¤>
```

### ERC-721.rs ì½”ë“œ ë¶„ì„

```rust
//! ERC-721 í‘œì¤€ì˜ êµ¬í˜„
//! (https://github.com/OffchainLabs/stylus-workshop-nft/ êµ¬í˜„ì„ ê¸°ë°˜ìœ¼ë¡œ í•¨)
//!
//! [`Erc721`] íƒ€ì…ì€ ëª¨ë“  í‘œì¤€ ë©”ì„œë“œë¥¼ ì œê³µí•˜ë©°,
//! ë‹¤ë¥¸ ê³„ì•½ íƒ€ì…ì— ì˜í•´ ìƒì†ë˜ë„ë¡ ì„¤ê³„ë˜ì—ˆë‹¤.
//!
//! [`Erc721Params`] íŠ¸ë ˆì´íŠ¸ë¥¼ í†µí•´ [`Erc721`]ì˜ ë™ì‘ì„ êµ¬ì„±í•  ìˆ˜ ìˆìœ¼ë©°,
//! ì´ë¥¼ í†µí•´ ì´ë¦„, ì‹¬ë³¼, í† í° URIë¥¼ ì§€ì •í•  ìˆ˜ ìˆë‹¤.
//!
//! ì´ ì½”ë“œëŠ” ê°ì‚¬ë˜ì§€ ì•Šì•˜ìœ¼ë©° í”„ë¡œë•ì…˜ ì‚¬ìš©ì— ì í•©í•˜ì§€ ì•ŠìŒì„ ìœ ì˜í•˜ì.

use alloc::{string::String, vec, vec::Vec};
use alloy_primitives::{Address, U256};
use alloy_sol_types::{sol, SolError};
use core::{borrow::BorrowMut, marker::PhantomData};
use stylus_sdk::{
    abi::Bytes,
    evm,
    msg,
    prelude::*
};

pub trait Erc721Params {
    /// ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ NFT ì´ë¦„.
    const NAME: &'static str;

    /// ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ NFT ì‹¬ë³¼.
    const SYMBOL: &'static str;
}

sol_storage! {
    /// Erc721ì€ ëª¨ë“  ERC-721 ë©”ì„œë“œë¥¼ êµ¬í˜„í•œë‹¤.
    pub struct Erc721<T: Erc721Params> {
        /// í† í° IDì—ì„œ ì†Œìœ ì ë§¤í•‘
        mapping(uint256 => address) owners;
        /// ì‚¬ìš©ìì—ì„œ ì”ì•¡ ë§¤í•‘
        mapping(address => uint256) balance;
        /// í† í° IDì—ì„œ ìŠ¹ì¸ëœ ì‚¬ìš©ì ë§¤í•‘
        mapping(uint256 => address) approved;
        /// ì‚¬ìš©ìì—ì„œ ìš´ì˜ì ë§¤í•‘ (ìš´ì˜ìëŠ” ì†Œìœ ìì˜ ëª¨ë“  NFTë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆìŒ)
        mapping(address => mapping(address => bool)) approved_for_all;
        /// ì´ ë°œí–‰ëŸ‰
        uint256 total_supply;
        /// [`Erc721Params`]ë¥¼ í—ˆìš©í•˜ëŠ” ë° ì‚¬ìš©ë¨
        PhantomData<T> phantom;
    }
}

// ì´ë²¤íŠ¸ ë° Solidity ì˜¤ë¥˜ íƒ€ì… ì„ ì–¸
sol! {
    event Transfer(address indexed from, address indexed to, uint256 indexed token_id);
    event Approval(address indexed owner, address indexed approved, uint256 indexed token_id);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    // í† í° IDê°€ ë°œí–‰ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì†Œê°ë¨
    error InvalidTokenId(uint256 token_id);
    // ì§€ì •ëœ ì£¼ì†Œê°€ ì§€ì •ëœ í† í° IDì˜ ì†Œìœ ìê°€ ì•„ë‹˜
    error NotOwner(address from, uint256 token_id, address real_owner);
    // ì§€ì •ëœ ì£¼ì†Œê°€ ì§€ì •ëœ í† í° IDë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¶Œí•œì´ ì—†ìŒ
    error NotApproved(address owner, address spender, uint256 token_id);
    // í† í° IDë¥¼ ì œë¡œ ì£¼ì†Œë¡œ ì „ì†¡í•˜ë ¤ê³  ì‹œë„í•¨
    error TransferToZero(uint256 token_id);
    // ìˆ˜ì‹ ì ì£¼ì†Œê°€ ì§€ì •ëœ í† í° IDì˜ ìˆ˜ì‹ ì„ ê±°ë¶€í•¨
    error ReceiverRefused(address receiver, uint256 token_id, bytes4 returned);
}

/// ë©”ì„œë“œê°€ ì‹¤íŒ¨í•  ìˆ˜ ìˆëŠ” ê²½ìš°ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
pub enum Erc721Error {
    InvalidTokenId(InvalidTokenId),
    NotOwner(NotOwner),
    NotApproved(NotApproved),
    TransferToZero(TransferToZero),
    ReceiverRefused(ReceiverRefused),
    ExternalCall(stylus_sdk::call::Error),
}

/// ê³§ ì´ ì‘ì—…ì„ ì •ë¦¬í•˜ê¸° ìœ„í•´ `#[derive(SolidityError)]`ì„ ì œê³µí•  ì˜ˆì •ì´ë‹¤.
impl From<stylus_sdk::call::Error> for Erc721Error {
    fn from(err: stylus_sdk::call::Error) -> Self {
        Self::ExternalCall(err)
    }
}

/// ê³§ ì´ ì‘ì—…ì„ ì •ë¦¬í•˜ê¸° ìœ„í•´ `#[derive(SolidityError)]`ì„ ì œê³µí•  ì˜ˆì •ì´ë‹¤.
impl From<Erc721Error> for Vec<u8> {
    fn from(val: Erc721Error) -> Self {
        match val {
            Erc721Error::InvalidTokenId(err) => err.encode(),
            Erc721Error::NotOwner(err) => err.encode(),
            Erc721Error::NotApproved(err) => err.encode(),
            Erc721Error::TransferToZero(err) => err.encode(),
            Erc721Error::ReceiverRefused(err) => err.encode(),
            Erc721Error::ExternalCall(err) => err.into(),
        }
    }
}

// ì´ ë©”ì„œë“œë“¤ì€ ì™¸ë¶€ ë©”ì„œë“œì—ì„œ ì‚¬ìš©ë˜ëŠ” ë„ìš°ë¯¸ ì—­í• ì„ í•œë‹¤.
// ì—¬ê¸°ì„œ "pub"ìœ¼ë¡œ í‘œì‹œëœ ë©”ì„œë“œëŠ” erc721 ëª¨ë“ˆ ì™¸ë¶€ì—ì„œ ì‚¬ìš© ê°€ëŠ¥ (ì¦‰, lib.rsì—ì„œ í˜¸ì¶œ ê°€ëŠ¥)í•˜ë‹¤.
impl<T: Erc721Params> Erc721<T> {
    /// msg::sender()ê°€ ì£¼ì–´ì§„ í† í°ì„ ì‚¬ìš©í•  ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸
    fn require_authorized_to_spend(&self, from: Address, token_id: U256) -> Result<(), Erc721Error> {
        let owner = self.owner_of(token_id)?;
        if from != owner {
            return Err(Erc721Error::NotOwner(NotOwner {
                from,
                token_id,
                real_owner: owner,
            }));
        }

        if msg::sender() == owner {
            return Ok(());
        }
        if self.approved_for_all.getter(owner).get(msg::sender()) {
            return Ok(());
        }
        if msg::sender() == self.approved.get(token_id) {
            return Ok(());
        }
        Err(Erc721Error::NotApproved(NotApproved {
            owner,
            spender: msg::sender(),
            token_id,
        }))
    }

    /// `token_id`ë¥¼ `from`ì—ì„œ `to`ë¡œ ì „ì†¡í•œë‹¤.
    /// ì´ í•¨ìˆ˜ëŠ” `from`ì´ í† í°ì˜ ì†Œìœ ìì¸ì§€ í™•ì¸í•˜ì§€ë§Œ, `to`ê°€ ì œë¡œ ì£¼ì†Œê°€ ì•„ë‹Œì§€ í™•ì¸í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ í•¨ìˆ˜ëŠ” ì†Œê°ì— ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
    pub fn transfer(&mut self, token_id: U256, from: Address, to: Address) -> Result<(), Erc721Error> {
        let mut owner = self.owners.setter(token_id);
        let previous_owner = owner.get();
        if previous_owner != from {
            return Err(Erc721Error::NotOwner(NotOwner {
                from,
                token_id,
                real_owner: previous_owner,
            }));
        }
        owner.set(to);

        // í˜„ì¬ë¡œì„œëŠ” ìŠ¤í† ë¦¬ì§€ë¥¼ ë‹¤ë£¨ëŠ” ê²ƒì´ ë²ˆê±°ë¡œìš¸ ìˆ˜ ìˆì§€ë§Œ, ì´ëŠ” ê³§ ì¶œì‹œë  Stylus SDK ë²„ì „ì—ì„œ ë³€ê²½ë  ì˜ˆì •ì´ë‹¤.
        let mut from_balance = self.balance.setter(from);
        let balance = from_balance.get() - U256::from(1);
        from_balance.set(balance);

        let mut to_balance = self.balance.setter(to);
        let balance = to_balance.get() + U256::from(1);
        to_balance.set(balance);

        self.approved.delete(token_id);
        evm::log(Transfer { from, to, token_id });
        Ok(())
    }

    /// `to` ì£¼ì†Œê°€ ê³„ì•½ì¸ ê²½ìš° `onERC721Received`ë¥¼ í˜¸ì¶œí•œë‹¤.
    /// ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•ŠëŠ”ë‹¤.
    fn call_receiver<S: TopLevelStorage>(
        storage: &mut S,
        token_id: U256,
        from: Address,
        to: Address,
        data: Vec<u8>,
    ) -> Result<(), Erc721Error> {
        if to.has_code() {
            let receiver = IERC721TokenReceiver::new(to);
            let received = receiver
                .on_erc_721_received(&mut *storage, msg::sender(), from, token_id, data)?
                .0;

            if u32::from_be_bytes(received) != ERC721_TOKEN_RECEIVER_ID {
                return Err(Erc721Error::ReceiverRefused(ReceiverRefused {
                    receiver: receiver.address,
                    token_id,
                    returned: received,
                }));
            }
        }
        Ok(())
    }

    /// ì „ì†¡ ë° `onERC721Received` í˜¸ì¶œ
    pub fn safe_transfer<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        token_id: U256,
        from: Address,
        to: Address,
        data: Vec<u8>,
    ) -> Result<(), Erc721Error> {
        storage.borrow_mut().transfer(token_id, from, to)?;
        Self::call_receiver(storage, token_id, from, to, data)
    }

    /// ìƒˆë¡œìš´ í† í°ì„ ë°œí–‰í•˜ê³  `to`ë¡œ ì „ì†¡í•œë‹¤.
    pub fn mint(&mut self, to: Address) -> Result<(), Erc721Error> {
        let new_token_id = self.total_supply.get();
        self.total_supply.set(new_token_id + U256::from(1u8));
        self.transfer(new_token_id, Address::default(), to)?;
        Ok(())
    }

    /// ìƒˆë¡œìš´ í† í°ì„ ë°œí–‰í•˜ê³  ì´ë¥¼ ì•ˆì „í•˜ê²Œ `to`ë¡œ ì „ì†¡í•œë‹¤.
    pub fn safe_mint<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        to: Address,
        data: Vec<u8>,
    ) -> Result<(), Erc721Error> {
        let this = storage.borrow_mut();
        let new_token_id = this.total_supply.get();
        this.total_supply.set(new_token_id + U256::from(1u8));
        Self::safe_transfer(storage, new_token_id, Address::default(), to, data)?;
        Ok(())
    }

    /// `from`ì—ì„œ `token_id` í† í°ì„ ì†Œê°í•œë‹¤.
    pub fn burn(&mut self, from: Address, token_id: U256) -> Result<(), Erc721Error> {
        self.transfer(token_id, from, Address::default())?;
        Ok(())
    }
}

sol_interface! {
    /// `IERC721TokenReceiver`ë¥¼ êµ¬í˜„í•˜ëŠ” ë‹¤ë¥¸ ê³„ì•½ì˜ `onERC721Received` ë©”ì„œë“œ í˜¸ì¶œì„ í—ˆìš©í•œë‹¤.
    interface IERC721TokenReceiver {
        function onERC721Received(address operator, address from, uint256 token_id, bytes data) external returns(bytes4);
    }
}

/// `IERC721TokenReceiver`ë¥¼ êµ¬í˜„í•˜ëŠ” ê³„ì•½ì—ì„œ ë°˜í™˜ë˜ëŠ” `onERC721Received`ì˜ ì„ íƒì.
const ERC721_TOKEN_RECEIVER_ID: u32 = 0x150b7a02;

// ì´ ë©”ì„œë“œë“¤ì€ ë‹¤ë¥¸ ê³„ì•½ì— ëŒ€í•´ ì™¸ë¶€ì ìœ¼ë¡œ ì‘ìš©í•œë‹¤.
#[external]
impl<T: Erc721Params> Erc721<T> {
    /// ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ NFT ì´ë¦„.
    pub fn name() -> Result<String, Erc721Error> {
        Ok(T::NAME.into())
    }

    /// ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ NFT ì‹¬ë³¼.
    pub fn symbol() -> Result<String, Erc721Error> {
        Ok(T::SYMBOL.into())
    }

    /// NFTê°€ ì£¼ì–´ì§„ í‘œì¤€ì„ ì§€ì›í•˜ëŠ”ì§€ ì—¬ë¶€.
    pub fn supports_interface(interface: [u8; 4]) -> Result<bool, Erc721Error> {
        if interface == [0xff; 4] {
            // ERC165 í‘œì¤€ì—ì„œ íŠ¹ë³„íˆ ì²˜ë¦¬ë¨
            return Ok(false);
        }

        const IERC165: u32 = 0x01ffc9a7;
        const IERC721: u32 = 0x80ac58cd;
        const _IERC721_ENUMERABLE: u32 = 0x780e9d63; // TODO: í‘œì¤€ êµ¬í˜„

        Ok(matches!(u32::from_be_bytes(interface), IERC165 | IERC721))
    }

    /// ê³„ì •ì´ ì†Œìœ í•œ NFT ìˆ˜ë¥¼ ê°€ì ¸ì˜¨ë‹¤.
    pub fn balance_of(&self, owner: Address) -> Result<U256, Erc721Error> {
        Ok(self.balance.get(owner))
    }

    /// NFTì˜ ì†Œìœ ìë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤, ì¡´ì¬í•  ê²½ìš°.
    pub fn owner_of(&self, token_id: U256) -> Result<Address, Erc721Error> {
        let owner = self.owners.get(token_id);
        if owner.is_zero() {
            return Err(Erc721Error::InvalidTokenId(InvalidTokenId { token_id }));
        }
        Ok(owner)
    }

    /// `to` ì£¼ì†Œê°€ NFTë¥¼ ë°›ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•œ í›„ NFTë¥¼ ì „ì†¡í•œë‹¤.
    pub fn safe_transfer_from<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Erc721Error> {
        Self::safe_transfer_from_with_data(storage, from, to, token_id, Bytes(vec![]))
    }

    /// [`safe_transfer_from`]ê³¼ ë™ì¼í•˜ì§€ë§Œ, ìˆ˜ì‹ ìì—ê²Œ ì¶”ê°€ ë°ì´í„°ë¥¼ í¬í•¨í•œë‹¤.
    ///
    /// ì°¸ê³ : RustëŠ” ë™ì¼í•œ ì´ë¦„ì˜ ë©”ì„œë“œë¥¼ ì—¬ëŸ¬ ê°œ í—ˆìš©í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—,
    /// `#[selector]` ë§¤í¬ë¡œ ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ Solidity ì˜¤ë²„ë¡œë”©ì„ ì‹œë®¬ë ˆì´íŠ¸í•œë‹¤.
    #[selector(name = "safeTransferFrom")]
    pub fn safe_transfer_from_with_data<S: TopLevelStorage + BorrowMut<Self>>(
        storage: &mut S,
        from: Address,
        to: Address,
        token_id: U256,
        data: Bytes,
    ) -> Result<(), Erc721Error> {
        if to.is_zero() {
            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));
        }
        storage
            .borrow_mut()
            .require_authorized_to_spend(from, token_id)?;

        Self::safe_transfer(storage, token_id, from, to, data.0)
    }

    /// NFTë¥¼ ì „ì†¡í•œë‹¤.
    pub fn transfer_from(&mut self, from: Address, to: Address, token_id: U256) -> Result<(), Erc721Error> {
        if to.is_zero() {
            return Err(Erc721Error::TransferToZero(TransferToZero { token_id }));
        }
        self.require_authorized_to_spend(from, token_id)?;
        self.transfer(token_id, from, to)?;
        Ok(())
    }

    /// ê³„ì •ì— ì‚¬ìš©ìì˜ NFTë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ê¶Œí•œì„ ë¶€ì—¬í•œë‹¤.
    pub fn approve(&mut self, approved: Address, token_id: U256) -> Result<(), Erc721Error> {
        let owner = self.owner_of(token_id)?;

        // ê¶Œí•œ ìš”êµ¬
        if msg::sender() != owner && !self.approved_for_all.getter(owner).get(msg::sender()) {
            return Err(Erc721Error::NotApproved(NotApproved {
                owner,
                spender: msg::sender(),
                token_id,
            }));
        }
        self.approved.insert(token_id, approved);

        evm::log(Approval {
            approved,
            owner,
            token_id,
        });
        Ok(())
    }

    /// ê³„ì •ì— ì‚¬ìš©ìì˜ ëª¨ë“  NFTë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ê¶Œí•œì„ ë¶€ì—¬í•œë‹¤.
    pub fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Erc721Error> {
        let owner = msg::sender();
        self.approved_for_all
            .setter(owner)
            .insert(operator, approved);

        evm::log(ApprovalForAll {
            owner,
            operator,
            approved,
        });
        Ok(())
    }

    /// NFTë¥¼ ê´€ë¦¬í•˜ëŠ” ê³„ì •ì„ ê°€ì ¸ì˜¤ê±°ë‚˜ ê´€ë¦¬ë˜ì§€ ì•ŠëŠ” ê²½ìš° 0ì„ ë°˜í™˜í•œë‹¤.
    pub fn get_approved(&mut self, token_id: U256) -> Result<Address, Erc721Error> {
        Ok(self.approved.get(token_id))
    }

    /// ê³„ì •ì´ ì‚¬ìš©ìì˜ ëª¨ë“  NFTë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ê¶Œí•œì„ ë¶€ì—¬ë°›ì•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ê²°ì •í•œë‹¤.
    pub fn is_approved_for_all(&mut self, owner: Address, operator: Address) -> Result<bool, Erc721Error> {
        Ok(self.approved_for_all.getter(owner).get(operator))
    }
}

```
